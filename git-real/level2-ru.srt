1
00:00:03,255 --> 00:00:06,970
Git это распределенный источник
контроля хранения.

2
00:00:06,970 --> 00:00:09,400
Я пытался представить движение
кластеров информации

3
00:00:09,400 --> 00:00:12,700
через файловую систему.

4
00:00:12,700 --> 00:00:13,820
Где сообщения коммитов,
как книга истории?

5
00:00:13,820 --> 00:00:16,535
Я продолжал мечтать о
репозитории,

6
00:00:16,535 --> 00:00:18,900
я думал, что никогда не увижу.

7
00:00:18,900 --> 00:00:21,530
И потом, однажды: Git Real.
(появился git)

8
00:00:21,530 --> 00:00:27,380
[ИГРАЕТ МУЗЫКА]

9
00:00:27,380 --> 00:00:29,850
Вы смотрите на Git Real, и это второй уровень, в котором

10
00:00:29,850 --> 00:00:32,450
мы собираемся поговорить о
staging и тем что происходит удалённо.

11
00:00:32,450 --> 00:00:34,980
Итак, скажем, вы в своём
локальном репозитории и вы внесли

12
00:00:34,980 --> 00:00:37,620
изменение в файл, но вы
не помните, что за

13
00:00:37,620 --> 00:00:41,550
изменение это было. Как, для примера,
файл лицензии вот тут.

14
00:00:41,550 --> 00:00:43,400
Чтобы выяснить что за изменение
это было, вы можете выполнить

15
00:00:43,400 --> 00:00:45,160
команду
git diff

16
00:00:45,160 --> 00:00:47,310
И вы сразу увидите.
Она покажет вам

17
00:00:47,310 --> 00:00:49,820
отличия в подготовительной стадии
с момента последнего commit.

18
00:00:49,820 --> 00:00:52,200
Красным будет обозначено
то, что было удалено,

19
00:00:52,200 --> 00:00:54,420
а зеленым то, что было добавлено.

20
00:00:54,420 --> 00:00:56,980
Результаты команды diffs
будет не так просто

21
00:00:56,980 --> 00:00:57,610
понять.

22
00:00:57,610 --> 00:01:00,430
К счастью, существуют инструменты,
которые облегчают чтение,

23
00:01:00,430 --> 00:01:03,260
мы посмотрим на них
в самом конце.

24
00:01:03,260 --> 00:01:04,890
Но давайте продолжим и добавим,

25
00:01:04,890 --> 00:01:06,800
наш файл с лицензией в подготовительную зону.

26
00:01:06,800 --> 00:01:09,460
Однажды добавив его туда,
если мы наберем git diff снова

27
00:01:09,460 --> 00:01:12,690
ничего не выведется
потому что тут нет

28
00:01:12,690 --> 00:01:16,240
никаких различий с момента
изменений на последнем этапе.

29
00:01:16,240 --> 00:01:18,950
Если мы хотим посмотреть изменений
с помощью diff
на всех этапах

30
00:01:18,950 --> 00:01:22,640
мы можем написать git diff --staged.
И мы получим тот же самый вывод

31
00:01:22,640 --> 00:01:25,400
на экране, что и был раньше.

32
00:01:25,400 --> 00:01:27,450
Итак, если мы сейчас запросим status
то мы увидим наш файл

33
00:01:27,450 --> 00:01:29,560
с лицензией, который помещен
в подготовительный этап

34
00:01:29,560 --> 00:01:30,920
он готов к commit.

35
00:01:30,920 --> 00:01:33,620
Но, что если мы поместим в подготовительный этап

36
00:01:33,620 --> 00:01:35,210
то, что мы не хотели туда помещать?

37
00:01:35,210 --> 00:01:37,900
Имейте в виду, у вас
может быть много изменённых

38
00:01:37,900 --> 00:01:41,100
файлов и возможно, вы захотите взять два из них
и сделать только commit

39
00:01:41,100 --> 00:01:43,080
на одном из них, а потом взять ещё два
файла и объединить в

40
00:01:43,080 --> 00:01:44,130
следующий commit.

41
00:01:44,130 --> 00:01:46,900
Итак, как нам получить файлы обратно
из зоны подготовки?

42
00:01:46,900 --> 00:01:50,350
Хорошо, вы заметите это вывод git status
скажет использовать

43
00:01:50,350 --> 00:01:54,460
git, reset, HEAD, а затем
имя файла для вытаскивания
из зоны подготовки.

44
00:01:54,460 --> 00:01:57,070
Затем, когда мы запускаем команду, вы можете видеть, что

45
00:01:57,070 --> 00:01:59,360
файл с лицензией был исключен.

46
00:01:59,360 --> 00:02:02,900
Вы можете удивиться,
что такое HEAD

47
00:02:02,900 --> 00:02:07,860
Ну, HEAD относится к последнему
commit в текущей ветке,

48
00:02:07,860 --> 00:02:10,199
или линии времени
на которой мы находимся.

49
00:02:10,199 --> 00:02:13,000
Теперь если мы запустим git status
мы увидим, что файл с лицензией

50
00:02:13,000 --> 00:02:15,810
не в подготовительной зоне,
но в нём всё равно есть

51
00:02:15,810 --> 00:02:17,130
изменения.

52
00:02:17,130 --> 00:02:19,660
Но что если мы вдруг передумали
и мы не хотим этих

53
00:02:19,660 --> 00:02:20,700
изменений?

54
00:02:20,700 --> 00:02:24,770
Что если мы хотим вернуть его
в состояние в котором он был

55
00:02:24,770 --> 00:02:28,440
в последний commit, или
в последний раз, когда он был изменен?

56
00:02:28,440 --> 00:02:32,780
Что ж, мы может сделать
git checkout, --,

57
00:02:32,780 --> 00:02:33,720
затем имя файла.

58
00:02:33,720 --> 00:02:35,730
Поэтому, если мы это сделаем, и снова запустим git status, мы

59
00:02:35,730 --> 00:02:37,610
увидим, что этот файл
вернулся в своё

60
00:02:37,610 --> 00:02:40,320
прежнее состояние.

61
00:02:40,320 --> 00:02:42,470
Теперь давайте продолжим и внесем
изменения в readme,

62
00:02:42,470 --> 00:02:44,440
говоря о том, как торт может быть обманчив.

63
00:02:44,440 --> 00:02:47,710
Если мы хотим сделать commit для
этих изменений, мы должны были бы добавить его

64
00:02:47,710 --> 00:02:49,510
и только затем сделать commit.

65
00:02:49,510 --> 00:02:51,140
Хорошо, есть сокращение.

66
00:02:51,140 --> 00:02:54,250
Мы можем запустить git commit -a -m,

67
00:02:54,250 --> 00:02:55,520
на пояснении к commit.
(commit message)

68
00:02:55,520 --> 00:02:57,840
На самом деле, всё, что делает
это добавляет любой наш

69
00:02:57,840 --> 00:03:02,110
отслеживаемый файл в подготовительную стадию
и потом делает commit.

70
00:03:02,110 --> 00:03:05,250
Нюанс здесь заключается в том
не добавит файлы

71
00:03:05,250 --> 00:03:06,870
которые мы не собираемся отслеживать.

72
00:03:06,870 --> 00:03:09,440
Поэтому, если мы создали новый файл
и запустили эту команду

73
00:03:09,440 --> 00:03:13,650
и он не будет добавлен в commit.

74
00:03:13,650 --> 00:03:16,040
Однажды настанет такое время
когда вы запустите Git, где

75
00:03:16,040 --> 00:03:18,060
соберетесь сделать commit, но потом

76
00:03:18,060 --> 00:03:21,740
моментально об этом пожалеете,
потому что, вероятно, вы забыли добавить

77
00:03:21,740 --> 00:03:23,990
файл или сделать какие-нибудь
изменения

78
00:03:23,990 --> 00:03:25,270
которые хотели сделать.

79
00:03:25,270 --> 00:03:26,550
Что с этим делать?

80
00:03:26,550 --> 00:03:29,470
К счастью, у нас есть команда
git reset

81
00:03:29,470 --> 00:03:32,660
она отменит последний commit и
перенесет всё из этого commit

82
00:03:32,660 --> 00:03:35,540
обратно в зону подготовки.

83
00:03:35,540 --> 00:03:38,710
Так что команда HEAD вы видите там с маленькой тильдой,

84
00:03:38,710 --> 00:03:42,520
это говорит о том, что надо продвинуться
на один commit назад

85
00:03:42,520 --> 00:03:44,290
до текущего HEAD.

86
00:03:44,290 --> 00:03:46,600
Итак, теперь если запустить git status
можно увидеть что наши изменения

87
00:03:46,600 --> 00:03:48,860
из этого commit
теперь в зоне подготовки.

88
00:03:48,860 --> 00:03:53,200
Я могу делать изменения, добавлять файлы
если захочу и сделать
commit повторно

89
00:03:53,200 --> 00:03:57,150
Другой способ модификации commit — использовать amend параметр.

90
00:03:57,150 --> 00:04:00,910
Поэтому, если вдруг захотелось
добавить todo.txt к нашему последнему

91
00:04:00,910 --> 00:04:04,450
commit, мы можем просто добавить его
в зону подготовки и потом сделать
git

92
00:04:04,450 --> 00:04:07,760
commit --amend, который добавит его к

93
00:04:07,760 --> 00:04:09,180
последнему commit.

94
00:04:09,180 --> 00:04:11,970
И тогда, если мы захотим, мы можем
добавить новое описание commit

95
00:04:11,970 --> 00:04:13,770
которое перезапишет

96
00:04:13,770 --> 00:04:15,250
существующее описание commit.

97
00:04:20,790 --> 00:04:22,810
Вот две команды, которые
мы только что прошли.

98
00:04:22,810 --> 00:04:25,540
У вас есть git reset,
который откатит обратно

99
00:04:25,540 --> 00:04:27,030
последний commit.

100
00:04:27,030 --> 00:04:29,970
И еще git commit amend
который добавит то, что нужно

101
00:04:29,970 --> 00:04:31,100
к последнему commit.

102
00:04:31,100 --> 00:04:33,110
Есть ещё пару вещей,
которые вам стоит знать.

103
00:04:33,110 --> 00:04:36,650
Если вы напечатаете git reset hard HEAD, это

104
00:04:36,650 --> 00:04:38,230
удалит последний commit.

105
00:04:38,230 --> 00:04:42,160
Поэтому если что-то пойдёт не так
и вы захотите это удалить,

106
00:04:42,160 --> 00:04:43,890
вы запускаете команду hard HEAD.

107
00:04:43,890 --> 00:04:46,810
Но что если вы захотите
отменить несколько последних commit'ов?

108
00:04:46,810 --> 00:04:50,380
Что ж, добавьте одну тильду (~)
в конце.

109
00:04:50,380 --> 00:04:53,140
Это удалит последние два commit'а до

110
00:04:53,140 --> 00:04:54,990
текущего HEAD.

111
00:04:54,990 --> 00:04:57,680
Итак, до сих пор, мы работали
с нашим локальным

112
00:04:57,680 --> 00:05:01,880
репозиторием на нашем компьютере,
но как мы сможем выложить наш

113
00:05:01,880 --> 00:05:05,840
репозиторий для других людей
что бы они могли сделать вклад в него?

114
00:05:05,840 --> 00:05:08,470
Что ж, это то место где появляются команды
push и pull.

115
00:05:08,470 --> 00:05:12,140
Итак, вот я нахожусь в моей локальной master ветке, я могу выложить её

116
00:05:12,140 --> 00:05:15,540
в удалённый репозиторий, a затем
остальные могут забрать изменения себе

117
00:05:15,540 --> 00:05:17,730
в локальный репозиторий и начать
делать изменения.

118
00:05:17,730 --> 00:05:19,490
И когда они закончат,
смогут отправить обратно

119
00:05:19,490 --> 00:05:21,550
свои изменения.

120
00:05:21,550 --> 00:05:23,790
Когда мы имеем дело с удаленными
репозиториями мы используем

121
00:05:23,790 --> 00:05:25,350
команду git remote, которую рассмотрим

122
00:05:25,350 --> 00:05:27,110
через минуту.

123
00:05:27,110 --> 00:05:29,230
Другая вещь, которую стоит упомянуть
это то, что Git

124
00:05:29,230 --> 00:05:31,810
не заботится
за вас о контроле доступа.

125
00:05:31,810 --> 00:05:35,120
Нельзя взять и сказать:
"только у вот этих людей будет доступ

126
00:05:35,120 --> 00:05:37,310
к этому репозиторию, и только
эта группа людей будет

127
00:05:37,310 --> 00:05:38,940
иметь доступ к вот этому репозиторию."

128
00:05:38,940 --> 00:05:40,635
Вот здесь вам понадобиться дополнительное
программное обеспечение.

129
00:05:40,635 --> 00:05:44,260
Вы либо захотите использовать
такие хостинги, как

130
00:05:44,260 --> 00:05:46,350
GitHub или BitBucket, чтобы они позаботились

131
00:05:46,350 --> 00:05:47,590
о контроле доступа.

132
00:05:47,590 --> 00:05:50,050
Или если вы хотите развернуть
собственный, можете попробовать

133
00:05:50,050 --> 00:05:53,400
что-нибудь вроде Gitosis или Gitorious и
они позаботятся о контроле доступа,

134
00:05:53,400 --> 00:05:55,910
и управлению конфигурациями.

135
00:05:55,910 --> 00:05:58,870
Если мы хотим завести свой
репозиторий на GitHub, нам нужно

136
00:05:58,870 --> 00:06:01,510
создать учетную запись GitHub и затем создать новый

137
00:06:01,510 --> 00:06:02,820
репозиторий на GitHub.

138
00:06:02,820 --> 00:06:05,030
Нам покажут форму, которая
выглядит вот так.

139
00:06:05,030 --> 00:06:08,570
Мы указываем имя репозитория
и затем выбираем

140
00:06:08,570 --> 00:06:09,730
пару вариантов.

141
00:06:09,730 --> 00:06:12,920
Как только мы его создали, GitHub
даст нам URL ссылку.

142
00:06:12,920 --> 00:06:15,570
Чтобы отправить изменения на GitHub, для начала
нам надо запустить Git,

143
00:06:15,570 --> 00:06:18,240
remote, add, origin.

144
00:06:18,240 --> 00:06:19,960
Origin — это удалённое имя.

145
00:06:19,960 --> 00:06:23,190
Мы можем дать ему любое имя, но,
мы обычно ссылаемся на наш

146
00:06:23,190 --> 00:06:27,170
канонический репозиторий, наш
официальный репозиторий, которым

147
00:06:27,170 --> 00:06:30,570
большинство наших людей
использовали наш проект как основой (origin).

148
00:06:30,570 --> 00:06:32,280
Поэтому "оригинальный" (origin),
так его и назовём.

149
00:06:32,280 --> 00:06:36,290
И затем мы укажем URL-адрес, который нам дал GitHub.

150
00:06:36,290 --> 00:06:38,320
Чтобы получить список всех удаленных репозиториев (remotes)
о которых знает наш локальный

151
00:06:38,320 --> 00:06:42,400
репозиторий, мы можем
просто написать git remote -v.

152
00:06:42,400 --> 00:06:47,590
На самом деле мы пока ещё
не отправили изменения в наш репозиторий.

153
00:06:47,590 --> 00:06:51,110
Эти remotes
как закладки.

154
00:06:51,110 --> 00:06:55,840
Мы делаем закладки на
URL ссылки оригинала, который

155
00:06:55,840 --> 00:06:57,850
в свою очередь, может содержать
в себе другие репозитории.

156
00:06:57,850 --> 00:07:01,670
Теперь, если мы захотим отправить изменения в наш
репозиторий, мы просто напишем
git push

157
00:07:01,670 --> 00:07:05,650
указывая имя удалённого
который, конечно же

158
00:07:05,650 --> 00:07:09,340
"origin". И указываем локальную ветку
которую мы хотим отправить туда.

159
00:07:09,340 --> 00:07:11,670
В данном случае, это мастер ветка (master branch).

160
00:07:11,670 --> 00:07:13,285
Поскольку мы используем GitHub,
нас спросят

161
00:07:13,285 --> 00:07:18,310
имя пользователя и пароль от GitHub
для авторизации чтобы отправить (push) изменения

162
00:07:18,310 --> 00:07:19,660
на удаленный GitHub.

163
00:07:19,660 --> 00:07:22,250
Теперь если вам не хочется каждый раз вводить свое имя пользователя и пароль

164
00:07:22,250 --> 00:07:24,800
чтобы делать push,
вам надо будет пройти

165
00:07:24,800 --> 00:07:27,620
по этой ссылке внизу
которая кеширует пароль (password caching)

166
00:07:27,620 --> 00:07:31,020
но сделать это нужно только один раз.

167
00:07:31,020 --> 00:07:33,800
Итак, мы отправили изменения из локального
репозитория в GitHub

168
00:07:33,800 --> 00:07:37,010
сейчас, если мы откроем
браузер и обновим страницу

169
00:07:37,010 --> 00:07:39,910
мы увидим, что GitHub теперь
знает о нашем репозитории и

170
00:07:39,910 --> 00:07:40,980
всей информации, что хранится в нём.

171
00:07:40,980 --> 00:07:43,130
На этой странице можно заметить
что есть кнопка commit

172
00:07:43,130 --> 00:07:44,310
и кнопка history (история).

173
00:07:44,310 --> 00:07:47,320
Если мы нажмём на них, то,
получим ту же информацию, что и

174
00:07:47,320 --> 00:07:49,070
получали ранее из git log.

175
00:07:49,070 --> 00:07:53,350
Мы можем просматривать все
commits внутри нашего репозитория.

176
00:07:53,350 --> 00:07:56,800
Итак, мы отправили изменения из локального
репозитория в GitHub, но как

177
00:07:56,800 --> 00:07:58,400
мы вытянем их обратно?

178
00:07:58,400 --> 00:08:00,380
Как нам это сделать?

179
00:08:00,380 --> 00:08:03,130
Ну, для этого есть команда
git pull.

180
00:08:03,130 --> 00:08:04,950
Это то, что вы захотите запустить
когда знаете, что

181
00:08:04,950 --> 00:08:06,760
другие люди сделали какие-нибудь изменения,
вы ведь не единственный

182
00:08:06,760 --> 00:08:08,950
кто работает над проектом,
и вы захотите

183
00:08:08,950 --> 00:08:09,850
получить изменения, сделанные ими.

184
00:08:09,850 --> 00:08:11,070
Вы запускаете git pull.

185
00:08:11,070 --> 00:08:15,230
Это пойдет на GitHub и вытянет из него изменения

186
00:08:15,230 --> 00:08:17,970
и синхронизирует с вашим локальным репозиторием.

187
00:08:17,970 --> 00:08:22,590
Итак, у нас есть GitHub, как каноническое
удалённое хранилище, которые мы назвали "origin"

188
00:08:22,590 --> 00:08:25,340
но обычно проект не хранится
на разных удалённых сервисах.

189
00:08:25,340 --> 00:08:28,850
У нас может быть тестовый сервер
который будет выполнять для нас тесты

190
00:08:28,850 --> 00:08:31,960
периодически мы будем делать туда push
нашего репозитория.

191
00:08:31,960 --> 00:08:35,600
У нас может быть хостинг провайдер
на котором будет лежать

192
00:08:35,600 --> 00:08:39,039
продакшн код, и мы, возможно, захотим отправить

193
00:08:39,039 --> 00:08:42,890
на наш рабочий сервер, чтобы был там запущен.

194
00:08:42,890 --> 00:08:45,960
Как мы заметили ранее, чтобы добавить
новое удалённое место хранения (remote),
нужно использовать вот такой синтаксис,

195
00:08:45,960 --> 00:08:49,370
git remote add "имя",
это может быть любое имя, и

196
00:08:49,370 --> 00:08:50,600
затем адрес.

197
00:08:50,600 --> 00:08:54,670
Чтобы удалить remotes мы просто делаем
git remote rm

198
00:08:54,670 --> 00:08:55,570
и указываем имя.

199
00:08:55,570 --> 00:08:58,470
И наконец, чтобы отправить репозиторий
на удалённые сервера (remotes), мы запускаем

200
00:08:58,470 --> 00:09:00,870
git push -u и указываем

201
00:09:00,870 --> 00:09:02,780
имя и нужную ветку.

202
00:09:02,780 --> 00:09:05,600
Вам может быть интересно, что тут делает -u?

203
00:09:05,600 --> 00:09:08,760
В основном это делает так, чтобы в следующий раз запустить git push, вы

204
00:09:08,760 --> 00:09:10,560
вам не нужно будет указывать
имя и ветку.

205
00:09:10,560 --> 00:09:14,220
Вы сможете просто написать git push.

206
00:09:14,220 --> 00:09:16,760
И наконец, я хочу рассказать о
Heroku — это платформа для хостинга

207
00:09:16,760 --> 00:09:18,300
и они используют remotes.

208
00:09:18,300 --> 00:09:20,630
Поэтому, если у вас есть учетная запись Heroku, вы установили

209
00:09:20,630 --> 00:09:23,940
Heroku gem, и после работы над своим кодом, вы напечатаете

210
00:09:23,940 --> 00:09:27,250
heroku create, вы можете увидеть, пару вещей выполненных для вас.

211
00:09:27,250 --> 00:09:30,640
Это ssh адрес git репозитория.

212
00:09:30,640 --> 00:09:35,090
Теперь до того как, начали использовать ссылку URL,
GitHub даст нам URL.

213
00:09:35,090 --> 00:09:37,480
Просто, проводя много времени,
работая с git репозиторием

214
00:09:37,480 --> 00:09:40,640
вам может понадобиться
ssh адрес.

215
00:09:40,640 --> 00:09:44,690
Как вы можете заметить, Heroku
уже добавился remote.

216
00:09:44,690 --> 00:09:47,090
И называется remote heroku.

217
00:09:47,090 --> 00:09:50,650
И когда мы захотим сделать push нашего
кода в Heroku, мы просто напишем

218
00:09:50,650 --> 00:09:53,900
git push heroku master.

219
00:09:53,900 --> 00:09:56,820
Это сделает push нашего локального
репозитория в Heroku.

220
00:09:56,820 --> 00:10:02,320
И когда Heroku получит код,
он автоматически развернет наш код.
(deploy)

221
00:10:02,320 --> 00:10:05,180
Последняя вещь перед тем, как закончить
второй уровень, помните

222
00:10:05,180 --> 00:10:07,490
это те команды, которыми
вы можете откатиться назад

223
00:10:07,490 --> 00:10:09,130
удаляя commit'ы?

224
00:10:09,130 --> 00:10:13,000
В общем вы захотите ими воспользоваться
только до того как, сделали

225
00:10:13,000 --> 00:10:14,150
commit, да?

226
00:10:14,150 --> 00:10:17,590
Потому что если есть какие-нибудь commit
и вы сделали push, а затем

227
00:10:17,590 --> 00:10:21,380
вы меняете их локально, это
как будто вы поменяли ход истории

228
00:10:21,380 --> 00:10:24,130
и, как мы все знаем, это очень опасно.

229
00:10:24,130 --> 00:10:26,000
Поэтому не делайте так.

230
00:10:26,000 --> 00:10:29,070
Пришло время окунуться
в упражнения и Git Real

231
00:10:29,070 --> 00:10:29,670
еще разок.

232
00:10:29,670 --> 00:10:32,791
[ИГРАЕТ МУЗЫКА]
